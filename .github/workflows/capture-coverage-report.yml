name: Capture Coverage Report

on:
  push:
    branches:
      - main
    paths:
      - "scripts/build_capture_coverage_report.py"
      - "scripts/build_capture_coverage_fixture_db.py"
      - "config/coverage_targets_config.v1.json"
      - "src/uroflow_mobile/clinical_hub.py"
      - ".github/workflows/capture-coverage-report.yml"
  schedule:
    - cron: "30 2 * * *"
  workflow_dispatch:
    inputs:
      site_id:
        description: "Optional site filter (default from repository variable CLINICAL_HUB_SITE_ID)"
        required: false
        type: string
      sync_id:
        description: "Optional sync_id filter"
        required: false
        type: string
      subject_id:
        description: "Optional subject filter"
        required: false
        type: string
      operator_id:
        description: "Optional operator filter"
        required: false
        type: string
      platform:
        description: "Optional platform filter"
        required: false
        type: choice
        options:
          - ""
          - ios
          - android
        default: ""
      capture_mode:
        description: "Optional capture mode filter"
        required: false
        type: choice
        options:
          - ""
          - water_impact
          - jet_in_air_assist
          - fallback_non_water
        default: ""
      quality_status:
        description: "Quality status filter"
        required: false
        type: choice
        options:
          - all
          - valid
          - repeat
          - reject
        default: all
      targets_config:
        description: "Path to coverage targets JSON config (repo-relative)"
        required: false
        type: string
      enforce_coverage_gates:
        description: "Fail workflow when hard gates fail (empty = use repo variable)"
        required: false
        type: choice
        options:
          - ""
          - "true"
          - "false"
        default: ""
      db_path:
        description: "DB path in repo/runner (used only when CLINICAL_HUB_DB_URL secret is empty)"
        required: false
        type: string
      tracking_issue_number:
        description: "Issue number for coverage progress comments (default from repo variable)"
        required: false
        type: string
      post_tracking_comment:
        description: "Post tracking comment (defaults to true)"
        required: false
        type: choice
        options:
          - ""
          - "true"
          - "false"
        default: ""
      fallback_fixture_alert_days:
        description: "Consecutive fallback fixture days before alert issue (empty = repo variable/default)"
        required: false
        type: string

concurrency:
  group: capture-coverage-report-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  generate-report:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      contents: read
      issues: write

    env:
      DEFAULT_SITE_ID: ${{ vars.CLINICAL_HUB_SITE_ID }}
      DEFAULT_QUALITY_STATUS: ${{ vars.CLINICAL_HUB_QUALITY_STATUS }}
      DEFAULT_TARGETS_CONFIG: ${{ vars.CLINICAL_HUB_COVERAGE_TARGETS_CONFIG }}
      DEFAULT_ENFORCE_COVERAGE_GATES: ${{ vars.CLINICAL_HUB_ENFORCE_COVERAGE_GATES }}
      DEFAULT_TRACKING_ISSUE_NUMBER: ${{ vars.CLINICAL_HUB_COVERAGE_TRACKING_ISSUE }}
      DEFAULT_FALLBACK_FIXTURE_ALERT_DAYS: ${{ vars.CLINICAL_HUB_FALLBACK_FIXTURE_ALERT_DAYS }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"
          cache-dependency-path: pyproject.toml

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e ".[dev]"
          pip install reportlab

      - name: Resolve filters
        id: filters
        shell: bash
        run: |
          set -euo pipefail

          site_id="${{ github.event.inputs.site_id }}"
          sync_id="${{ github.event.inputs.sync_id }}"
          subject_id="${{ github.event.inputs.subject_id }}"
          operator_id="${{ github.event.inputs.operator_id }}"
          platform="${{ github.event.inputs.platform }}"
          capture_mode="${{ github.event.inputs.capture_mode }}"
          quality_status="${{ github.event.inputs.quality_status }}"
          targets_config="${{ github.event.inputs.targets_config }}"
          enforce_coverage_gates="${{ github.event.inputs.enforce_coverage_gates }}"

          if [[ -z "$site_id" ]]; then
            site_id="${DEFAULT_SITE_ID:-}"
          fi
          if [[ -z "$quality_status" ]]; then
            quality_status="${DEFAULT_QUALITY_STATUS:-all}"
          fi
          if [[ -z "$targets_config" ]]; then
            targets_config="${DEFAULT_TARGETS_CONFIG:-config/coverage_targets_config.v1.json}"
          fi
          if [[ -z "$enforce_coverage_gates" ]]; then
            enforce_coverage_gates="${DEFAULT_ENFORCE_COVERAGE_GATES:-false}"
          fi
          case "${enforce_coverage_gates,,}" in
            true|1|yes|y)
              enforce_coverage_gates="true"
              ;;
            *)
              enforce_coverage_gates="false"
              ;;
          esac

          echo "site_id=$site_id" >> "$GITHUB_OUTPUT"
          echo "sync_id=$sync_id" >> "$GITHUB_OUTPUT"
          echo "subject_id=$subject_id" >> "$GITHUB_OUTPUT"
          echo "operator_id=$operator_id" >> "$GITHUB_OUTPUT"
          echo "platform=$platform" >> "$GITHUB_OUTPUT"
          echo "capture_mode=$capture_mode" >> "$GITHUB_OUTPUT"
          echo "quality_status=$quality_status" >> "$GITHUB_OUTPUT"
          echo "targets_config=$targets_config" >> "$GITHUB_OUTPUT"
          echo "enforce_coverage_gates=$enforce_coverage_gates" >> "$GITHUB_OUTPUT"

      - name: Resolve data source
        id: source
        shell: bash
        run: |
          set -euo pipefail

          if [[ -n "${{ secrets.CLINICAL_HUB_URL }}" ]]; then
            echo "Using Clinical Hub API source."
            echo "source_mode=api" >> "$GITHUB_OUTPUT"
            echo "source_variant=api_secret" >> "$GITHUB_OUTPUT"
            echo "api_base_url=${{ secrets.CLINICAL_HUB_URL }}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [[ -n "${{ secrets.CLINICAL_HUB_DB_URL }}" ]]; then
            echo "Downloading clinical hub DB from CLINICAL_HUB_DB_URL..."
            curl --fail --location --silent --show-error \
              "${{ secrets.CLINICAL_HUB_DB_URL }}" \
              --output /tmp/clinical_hub.db
            echo "source_mode=db" >> "$GITHUB_OUTPUT"
            echo "source_variant=db_url_secret" >> "$GITHUB_OUTPUT"
            echo "db_path=/tmp/clinical_hub.db" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          db_path="${{ github.event.inputs.db_path }}"
          if [[ -z "$db_path" ]]; then
            db_path="data/clinical_hub.db"
          fi

          if [[ ! -f "$db_path" ]]; then
            echo "Database file '$db_path' is missing. Building fallback fixture DB..."
            PYTHONPATH=src python scripts/build_capture_coverage_fixture_db.py \
              --db-path /tmp/clinical_hub_fixture.db
            echo "source_mode=db" >> "$GITHUB_OUTPUT"
            echo "source_variant=fallback_fixture" >> "$GITHUB_OUTPUT"
            echo "db_path=/tmp/clinical_hub_fixture.db" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "source_mode=db" >> "$GITHUB_OUTPUT"
          echo "source_variant=local_db_path" >> "$GITHUB_OUTPUT"
          echo "db_path=$db_path" >> "$GITHUB_OUTPUT"

      - name: Generate coverage CSV and PDF
        id: generate
        shell: bash
        run: |
          set -euo pipefail

          report_dir="/tmp/capture-coverage-report/$(date -u +%Y%m%dT%H%M%SZ)"
          mkdir -p "$report_dir"
          csv_path="$report_dir/capture_coverage_summary.csv"
          pdf_path="$report_dir/capture_coverage_summary.pdf"
          sha_path="$csv_path.sha256"
          export TARGET_CSV="$csv_path"
          export TARGET_PDF="$pdf_path"
          export TARGET_SHA="$sha_path"

          args=(
            scripts/build_capture_coverage_report.py
            --source-mode "${{ steps.source.outputs.source_mode }}"
            --quality-status "${{ steps.filters.outputs.quality_status }}"
            --output-csv "$csv_path"
            --output-pdf "$pdf_path"
            --sha256-file "$sha_path"
          )

          if [[ "${{ steps.source.outputs.source_mode }}" == "api" ]]; then
            args+=(--api-base-url "${SOURCE_API_BASE_URL:-}")
            if [[ -n "${SOURCE_API_KEY:-}" ]]; then
              args+=(--api-key "${SOURCE_API_KEY}")
            fi
          else
            args+=(--db-path "${{ steps.source.outputs.db_path }}")
          fi

          if [[ -n "${{ steps.filters.outputs.site_id }}" ]]; then
            args+=(--site-id "${{ steps.filters.outputs.site_id }}")
          fi
          if [[ -n "${{ steps.filters.outputs.sync_id }}" ]]; then
            args+=(--sync-id "${{ steps.filters.outputs.sync_id }}")
          fi
          if [[ -n "${{ steps.filters.outputs.subject_id }}" ]]; then
            args+=(--subject-id "${{ steps.filters.outputs.subject_id }}")
          fi
          if [[ -n "${{ steps.filters.outputs.operator_id }}" ]]; then
            args+=(--operator-id "${{ steps.filters.outputs.operator_id }}")
          fi
          if [[ -n "${{ steps.filters.outputs.platform }}" ]]; then
            args+=(--platform "${{ steps.filters.outputs.platform }}")
          fi
          if [[ -n "${{ steps.filters.outputs.capture_mode }}" ]]; then
            args+=(--capture-mode "${{ steps.filters.outputs.capture_mode }}")
          fi

          PYTHONPATH=src python "${args[@]}"

          echo "report_dir=$report_dir" >> "$GITHUB_OUTPUT"
          echo "csv_path=$csv_path" >> "$GITHUB_OUTPUT"
        env:
          SOURCE_API_BASE_URL: ${{ steps.source.outputs.api_base_url }}
          SOURCE_API_KEY: ${{ secrets.CLINICAL_HUB_API_KEY }}
          FILTER_SITE_ID: ${{ steps.filters.outputs.site_id }}
          FILTER_SYNC_ID: ${{ steps.filters.outputs.sync_id }}
          FILTER_SUBJECT_ID: ${{ steps.filters.outputs.subject_id }}
          FILTER_OPERATOR_ID: ${{ steps.filters.outputs.operator_id }}
          FILTER_PLATFORM: ${{ steps.filters.outputs.platform }}
          FILTER_CAPTURE_MODE: ${{ steps.filters.outputs.capture_mode }}
          FILTER_QUALITY_STATUS: ${{ steps.filters.outputs.quality_status }}

      - name: Evaluate coverage gates
        id: gates
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
          import csv
          import json
          import math
          import os
          from pathlib import Path

          csv_path = Path("${{ steps.generate.outputs.csv_path }}")
          report_dir = Path("${{ steps.generate.outputs.report_dir }}")
          config_path = Path("${{ steps.filters.outputs.targets_config }}")
          output_path = report_dir / "coverage_gates.json"

          if not csv_path.exists():
              raise FileNotFoundError(f"coverage csv not found: {csv_path}")
          if not config_path.exists():
              raise FileNotFoundError(f"targets config not found: {config_path}")

          with csv_path.open("r", encoding="utf-8", newline="") as handle:
              rows = list(csv.DictReader(handle))
          row = rows[0] if rows else {}

          paired_total = float(row.get("paired_total", "0") or "0")
          denominator = paired_total if paired_total > 0 else 1.0
          quality_valid = float(row.get("quality_valid", "0") or "0")
          quality_repeat = float(row.get("quality_repeat", "0") or "0")
          quality_reject = float(row.get("quality_reject", "0") or "0")
          match_none = float(row.get("match_none", "0") or "0")

          metrics = {
              "paired_total": paired_total,
              "paired_with_capture": float(row.get("paired_with_capture", "0") or "0"),
              "paired_without_capture": float(row.get("paired_without_capture", "0") or "0"),
              "coverage_ratio": float(row.get("coverage_ratio", "0") or "0"),
              "quality_valid_count": quality_valid,
              "quality_repeat_count": quality_repeat,
              "quality_reject_count": quality_reject,
              "quality_valid_ratio": quality_valid / denominator,
              "quality_repeat_ratio": quality_repeat / denominator,
              "quality_reject_ratio": quality_reject / denominator,
              "capture_match_none_count": match_none,
              "capture_match_none_ratio": match_none / denominator,
          }

          config_payload = json.loads(config_path.read_text(encoding="utf-8"))
          if not isinstance(config_payload, dict):
              raise ValueError("coverage targets config must be a JSON object")
          gates = config_payload.get("gates")
          if not isinstance(gates, list) or len(gates) == 0:
              raise ValueError("coverage targets config must include non-empty 'gates' list")

          def evaluate(actual: float, operator: str, threshold: float) -> bool:
              if operator == ">=":
                  return actual >= threshold
              if operator == ">":
                  return actual > threshold
              if operator == "<=":
                  return actual <= threshold
              if operator == "<":
                  return actual < threshold
              if operator == "==":
                  return actual == threshold
              raise ValueError(f"Unsupported gate operator: {operator}")

          evaluations = []
          hard_passed = True
          warning_passed = True
          for index, gate in enumerate(gates):
              if not isinstance(gate, dict):
                  raise ValueError(f"gates[{index}] must be object")
              metric = gate.get("metric")
              operator = gate.get("operator")
              threshold = gate.get("threshold")
              if not isinstance(metric, str) or metric not in metrics:
                  raise ValueError(f"gates[{index}].metric is invalid: {metric!r}")
              if not isinstance(operator, str) or operator not in {">=", ">", "<=", "<", "=="}:
                  raise ValueError(f"gates[{index}].operator is invalid: {operator!r}")
              if not isinstance(threshold, (int, float)) or not math.isfinite(float(threshold)):
                  raise ValueError(f"gates[{index}].threshold must be finite number")
              severity = str(gate.get("severity", "hard")).strip().lower()
              if severity not in {"hard", "warning"}:
                  raise ValueError(f"gates[{index}].severity must be 'hard' or 'warning'")
              actual = float(metrics[metric])
              passed = evaluate(actual, operator, float(threshold))
              if severity == "hard" and not passed:
                  hard_passed = False
              if severity == "warning" and not passed:
                  warning_passed = False
              evaluations.append(
                  {
                      "id": gate.get("id") or metric,
                      "label": gate.get("label") or metric,
                      "metric": metric,
                      "operator": operator,
                      "threshold": float(threshold),
                      "actual": actual,
                      "severity": severity,
                      "passed": passed,
                  }
              )

          report = {
              "config_path": str(config_path),
              "config_version": config_payload.get("version"),
              "config_name": config_payload.get("name"),
              "metrics": metrics,
              "gates": evaluations,
              "hard_passed": hard_passed,
              "warning_passed": warning_passed,
              "overall_passed": hard_passed,
          }
          output_path.write_text(json.dumps(report, ensure_ascii=False, indent=2), encoding="utf-8")
          with Path(os.environ["GITHUB_OUTPUT"]).open("a", encoding="utf-8") as handle:
              handle.write(f"gates_json_path={output_path}\n")
              handle.write(f"hard_passed={'true' if hard_passed else 'false'}\n")
              handle.write(f"warning_passed={'true' if warning_passed else 'false'}\n")
          print(f"Coverage gates report saved: {output_path}")
          print(f"hard_passed={hard_passed}, warning_passed={warning_passed}")
          PY

      - name: Upload coverage report artifact
        uses: actions/upload-artifact@v4
        with:
          name: capture-coverage-report-${{ github.run_id }}
          path: ${{ steps.generate.outputs.report_dir }}
          if-no-files-found: error

      - name: Publish workflow summary
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
          import csv
          import os
          from pathlib import Path

          csv_path = Path("${{ steps.generate.outputs.csv_path }}")
          with csv_path.open("r", encoding="utf-8", newline="") as handle:
              rows = list(csv.DictReader(handle))
          row = rows[0] if rows else {}

          paired_total = int(row.get("paired_total", "0") or "0")
          paired_with_capture = int(row.get("paired_with_capture", "0") or "0")
          coverage_ratio = float(row.get("coverage_ratio", "0") or "0")
          hard_passed = "${{ steps.gates.outputs.hard_passed }}" or "false"
          warning_passed = "${{ steps.gates.outputs.warning_passed }}" or "false"
          enforce_hard = "${{ steps.filters.outputs.enforce_coverage_gates }}" or "false"
          gates_path = "${{ steps.gates.outputs.gates_json_path }}" or "-"
          targets_config = "${{ steps.filters.outputs.targets_config }}" or "-"

          summary_lines = [
              "## Capture Coverage Summary",
              f"- Source mode: `${{ steps.source.outputs.source_mode }}`",
              f"- Source variant: `${{ steps.source.outputs.source_variant }}`",
              f"- Paired total: `{paired_total}`",
              f"- Paired with capture: `{paired_with_capture}`",
              f"- Coverage ratio: `{coverage_ratio * 100:.1f}%`",
              f"- Site: `{row.get('site_id', '') or '-'}`",
              f"- Sync: `{row.get('sync_id', '') or '-'}`",
              f"- Quality filter: `{row.get('quality_status', '') or 'all'}`",
              f"- Targets config: `{targets_config}`",
              f"- Hard gates passed: `{hard_passed}`",
              f"- Warning gates passed: `{warning_passed}`",
              f"- Hard gate enforcement: `{enforce_hard}`",
              f"- Gates report: `{gates_path}`",
          ]
          Path(os.environ["GITHUB_STEP_SUMMARY"]).write_text(
              "\n".join(summary_lines) + "\n",
              encoding="utf-8",
          )
          PY

      - name: Resolve tracking comment settings
        id: tracking
        if: ${{ github.event_name == 'schedule' || github.event_name == 'workflow_dispatch' }}
        shell: bash
        run: |
          set -euo pipefail

          post_tracking_comment="${{ github.event.inputs.post_tracking_comment }}"
          if [[ -z "$post_tracking_comment" ]]; then
            post_tracking_comment="true"
          fi
          case "${post_tracking_comment,,}" in
            true|1|yes|y)
              post_tracking_comment="true"
              ;;
            *)
              post_tracking_comment="false"
              ;;
          esac

          issue_number="${{ github.event.inputs.tracking_issue_number }}"
          if [[ -z "$issue_number" ]]; then
            issue_number="${DEFAULT_TRACKING_ISSUE_NUMBER:-20}"
          fi
          if [[ -n "$issue_number" && ! "$issue_number" =~ ^[0-9]+$ ]]; then
            echo "Tracking issue number is not numeric: '$issue_number'. Commenting disabled."
            issue_number=""
            post_tracking_comment="false"
          fi

          echo "issue_number=$issue_number" >> "$GITHUB_OUTPUT"
          echo "post_tracking_comment=$post_tracking_comment" >> "$GITHUB_OUTPUT"

      - name: Resolve existing tracking issue comment
        id: tracking_existing
        if: ${{ steps.tracking.outputs.post_tracking_comment == 'true' && steps.tracking.outputs.issue_number != '' }}
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          comments_json_path="/tmp/issue-comments-${{ steps.tracking.outputs.issue_number }}.json"
          gh api "repos/${GITHUB_REPOSITORY}/issues/${{ steps.tracking.outputs.issue_number }}/comments?per_page=100" > "$comments_json_path"
          python - <<'PY'
          import json
          import os
          from pathlib import Path

          comments = json.loads(
              Path("/tmp/issue-comments-${{ steps.tracking.outputs.issue_number }}.json").read_text(
                  encoding="utf-8"
              )
          )
          output_path = Path(os.environ["GITHUB_OUTPUT"])
          existing_comment_id = ""
          existing_comment_body = ""
          marker = "<!-- coverage-tracking-comment:v1 -->"
          legacy_heading = "### Capture coverage daily update"

          for comment in reversed(comments):
              user = (comment.get("user") or {}).get("login", "")
              body = comment.get("body") or ""
              if user not in {"github-actions[bot]", "github-actions"}:
                  continue
              if marker in body or body.lstrip().startswith(legacy_heading):
                  existing_comment_id = str(comment.get("id") or "")
                  existing_comment_body = body
                  break

          if existing_comment_id:
              body_path = Path("/tmp/coverage-tracking-existing-comment.md")
              body_path.write_text(existing_comment_body, encoding="utf-8")
              with output_path.open("a", encoding="utf-8") as handle:
                  handle.write(f"existing_comment_id={existing_comment_id}\n")
                  handle.write(f"existing_comment_body_path={body_path}\n")
          PY

      - name: Resolve fallback fixture alert threshold
        id: fallback_alert
        if: ${{ github.event_name == 'schedule' || github.event_name == 'workflow_dispatch' }}
        shell: bash
        run: |
          set -euo pipefail
          threshold_days="${{ github.event.inputs.fallback_fixture_alert_days }}"
          if [[ -z "$threshold_days" ]]; then
            threshold_days="${DEFAULT_FALLBACK_FIXTURE_ALERT_DAYS:-3}"
          fi
          if [[ ! "$threshold_days" =~ ^[0-9]+$ ]] || [[ "$threshold_days" -lt 1 ]]; then
            echo "Invalid fallback_fixture_alert_days '$threshold_days', using default '3'."
            threshold_days="3"
          fi
          echo "threshold_days=$threshold_days" >> "$GITHUB_OUTPUT"

      - name: Build tracking issue comment
        id: tracking_comment
        if: ${{ steps.tracking.outputs.post_tracking_comment == 'true' && steps.tracking.outputs.issue_number != '' }}
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
          import csv
          import json
          import os
          import re
          from pathlib import Path

          csv_path = Path("${{ steps.generate.outputs.csv_path }}")
          gates_path = Path("${{ steps.gates.outputs.gates_json_path }}")
          comment_path = Path("${{ steps.generate.outputs.report_dir }}") / "coverage_tracking_comment.md"
          previous_comment_path = "${{ steps.tracking_existing.outputs.existing_comment_body_path }}"

          with csv_path.open("r", encoding="utf-8", newline="") as handle:
              rows = list(csv.DictReader(handle))
          row = rows[0] if rows else {}

          paired_total = int(float(row.get("paired_total", "0") or "0"))
          paired_with_capture = int(float(row.get("paired_with_capture", "0") or "0"))
          paired_without_capture = int(float(row.get("paired_without_capture", "0") or "0"))
          coverage_ratio = float(row.get("coverage_ratio", "0") or "0")
          hard_passed = "${{ steps.gates.outputs.hard_passed }}" == "true"
          warning_passed = "${{ steps.gates.outputs.warning_passed }}" == "true"

          failing = []
          if gates_path.exists():
              payload = json.loads(gates_path.read_text(encoding="utf-8"))
              for gate in payload.get("gates", []):
                  if not gate.get("passed", False):
                      label = gate.get("label") or gate.get("id") or gate.get("metric", "gate")
                      actual = gate.get("actual")
                      operator = gate.get("operator")
                      threshold = gate.get("threshold")
                      severity = gate.get("severity", "hard")
                      failing.append(
                          f"- `{severity}`: {label} (`{actual}` {operator} `{threshold}`)"
                      )

          run_url = (
              f"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          )
          source_mode = "${{ steps.source.outputs.source_mode }}"
          source_variant = "${{ steps.source.outputs.source_variant }}"
          site_id = row.get("site_id", "") or "-"
          quality_status = row.get("quality_status", "") or "all"
          generated_at = row.get("generated_at", "") or "${{ github.run_started_at }}"

          previous_body = ""
          previous_paired_total = None
          previous_coverage_ratio_pct = None
          previous_source_variant = None
          previous_streak_days = 0
          previous_generated_date = None
          if previous_comment_path:
              previous_path = Path(previous_comment_path)
              if previous_path.exists():
                  previous_body = previous_path.read_text(encoding="utf-8")
                  paired_match = re.search(r"- Paired total: `([0-9]+)`", previous_body)
                  if paired_match:
                      previous_paired_total = int(paired_match.group(1))
                  coverage_match = re.search(r"- Coverage ratio: `([0-9]+(?:\.[0-9]+)?)%`", previous_body)
                  if coverage_match:
                      previous_coverage_ratio_pct = float(coverage_match.group(1))
                  source_variant_match = re.search(
                      r"- Source variant: `([^`]+)`", previous_body
                  )
                  if source_variant_match:
                      previous_source_variant = source_variant_match.group(1)
                  streak_match = re.search(
                      r"- Fallback fixture streak days: `([0-9]+)`", previous_body
                  )
                  if streak_match:
                      previous_streak_days = int(streak_match.group(1))
                  generated_match = re.search(
                      r"- Generated at \(UTC\): `([^`]+)`", previous_body
                  )
                  if generated_match:
                      previous_generated_date = generated_match.group(1)[:10]

          current_generated_date = generated_at[:10] if generated_at else ""
          fallback_streak_days = 0
          if source_variant == "fallback_fixture":
              if previous_source_variant == "fallback_fixture":
                  if (
                      previous_generated_date
                      and current_generated_date
                      and previous_generated_date == current_generated_date
                  ):
                      fallback_streak_days = max(previous_streak_days, 1)
                  else:
                      fallback_streak_days = max(previous_streak_days, 1) + 1
              else:
                  fallback_streak_days = 1

          delta_lines = []
          if previous_paired_total is None or previous_coverage_ratio_pct is None:
              delta_lines.append("- Delta vs previous update: `n/a` (first tracked update)")
          else:
              paired_delta = paired_total - previous_paired_total
              coverage_delta_pp = (coverage_ratio * 100.0) - previous_coverage_ratio_pct
              delta_lines.append(
                  f"- Delta paired total vs previous: `{paired_delta:+d}`"
              )
              delta_lines.append(
                  f"- Delta coverage ratio vs previous: `{coverage_delta_pp:+.1f} pp`"
              )

          lines = [
              "<!-- coverage-tracking-comment:v1 -->",
              "### Capture coverage daily update",
              f"- Run: {run_url}",
              f"- Generated at (UTC): `{generated_at}`",
              f"- Source mode: `{source_mode}`",
              f"- Source variant: `{source_variant}`",
              f"- Fallback fixture streak days: `{fallback_streak_days}`",
              f"- Site: `{site_id}`",
              f"- Quality filter: `{quality_status}`",
              f"- Paired total: `{paired_total}`",
              f"- Paired with capture: `{paired_with_capture}`",
              f"- Paired without capture: `{paired_without_capture}`",
              f"- Coverage ratio: `{coverage_ratio * 100:.1f}%`",
              f"- Hard gates passed: `{str(hard_passed).lower()}`",
              f"- Warning gates passed: `{str(warning_passed).lower()}`",
          ]
          lines.extend(delta_lines)
          if failing:
              lines.append("- Failing gates:")
              lines.extend(failing)
          else:
              lines.append("- Failing gates: none")

          comment_path.write_text("\n".join(lines) + "\n", encoding="utf-8")
          with Path(os.environ["GITHUB_OUTPUT"]).open("a", encoding="utf-8") as handle:
              handle.write(f"comment_path={comment_path}\n")
              handle.write(f"source_variant={source_variant}\n")
              handle.write(f"fallback_streak_days={fallback_streak_days}\n")
          PY

      - name: Post tracking issue comment
        if: ${{ steps.tracking.outputs.post_tracking_comment == 'true' && steps.tracking.outputs.issue_number != '' }}
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          comment_body="$(cat "${{ steps.tracking_comment.outputs.comment_path }}")"
          if [[ -n "${{ steps.tracking_existing.outputs.existing_comment_id }}" ]]; then
            gh api --method PATCH \
              "repos/${GITHUB_REPOSITORY}/issues/comments/${{ steps.tracking_existing.outputs.existing_comment_id }}" \
              -f body="$comment_body" > /dev/null
            echo "Updated tracking comment id=${{ steps.tracking_existing.outputs.existing_comment_id }}."
          else
            gh issue comment "${{ steps.tracking.outputs.issue_number }}" \
              --repo "${GITHUB_REPOSITORY}" \
              --body-file "${{ steps.tracking_comment.outputs.comment_path }}" > /dev/null
            echo "Created new tracking comment."
          fi

      - name: Build hard-gate incident issue body
        id: hard_gate_incident
        if: ${{ github.event_name == 'schedule' && steps.gates.outputs.hard_passed != 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
          import csv
          import json
          import os
          from pathlib import Path

          csv_path = Path("${{ steps.generate.outputs.csv_path }}")
          gates_path = Path("${{ steps.gates.outputs.gates_json_path }}")
          body_path = Path("${{ steps.generate.outputs.report_dir }}") / "hard_gate_incident.md"
          run_url = f"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          with csv_path.open("r", encoding="utf-8", newline="") as handle:
              rows = list(csv.DictReader(handle))
          row = rows[0] if rows else {}
          generated_at = row.get("generated_at", "") or "${{ github.run_started_at }}"
          coverage_ratio = float(row.get("coverage_ratio", "0") or "0")
          paired_total = int(float(row.get("paired_total", "0") or "0"))
          paired_with_capture = int(float(row.get("paired_with_capture", "0") or "0"))
          paired_without_capture = int(float(row.get("paired_without_capture", "0") or "0"))

          failing_hard = []
          if gates_path.exists():
              payload = json.loads(gates_path.read_text(encoding="utf-8"))
              for gate in payload.get("gates", []):
                  if gate.get("severity") == "hard" and not gate.get("passed", False):
                      label = gate.get("label") or gate.get("id") or gate.get("metric", "gate")
                      actual = gate.get("actual")
                      operator = gate.get("operator")
                      threshold = gate.get("threshold")
                      failing_hard.append(
                          f"- {label}: `{actual}` {operator} `{threshold}`"
                      )

          lines = [
              "<!-- coverage-hard-gate-incident:v1 -->",
              "# Incident: Capture coverage hard gates failed",
              "",
              f"- Latest failing run: {run_url}",
              f"- Generated at (UTC): `{generated_at}`",
              f"- Site: `{row.get('site_id', '') or '-'}`",
              f"- Paired total: `{paired_total}`",
              f"- Paired with capture: `{paired_with_capture}`",
              f"- Paired without capture: `{paired_without_capture}`",
              f"- Coverage ratio: `{coverage_ratio * 100:.1f}%`",
              "",
              "## Failing hard gates",
          ]
          if failing_hard:
              lines.extend(failing_hard)
          else:
              lines.append("- hard gate failure detected, but no hard-gate details were parsed.")

          body_path.write_text("\n".join(lines) + "\n", encoding="utf-8")
          with Path(os.environ["GITHUB_OUTPUT"]).open("a", encoding="utf-8") as handle:
              handle.write("incident_title=Incident: Capture coverage hard gates failed\n")
              handle.write(f"incident_body_path={body_path}\n")
          PY

      - name: Upsert hard-gate incident issue
        if: ${{ github.event_name == 'schedule' && steps.gates.outputs.hard_passed != 'true' }}
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          title="${{ steps.hard_gate_incident.outputs.incident_title }}"
          body_path="${{ steps.hard_gate_incident.outputs.incident_body_path }}"

          existing_issue_number="$(gh issue list \
            --repo "${GITHUB_REPOSITORY}" \
            --state open \
            --search "\"${title}\" in:title" \
            --json number,title \
            --jq ".[] | select(.title == \"${title}\") | .number" | head -n 1)"

          if [[ -n "$existing_issue_number" ]]; then
            gh issue edit "$existing_issue_number" \
              --repo "${GITHUB_REPOSITORY}" \
              --add-label bug \
              --body-file "$body_path" > /dev/null
            echo "Updated incident issue #$existing_issue_number."
          else
            new_url="$(gh issue create \
              --repo "${GITHUB_REPOSITORY}" \
              --title "$title" \
              --label bug \
              --body-file "$body_path")"
            echo "Created incident issue: $new_url"
          fi

      - name: Manage fallback fixture streak alert issue
        if: ${{ github.event_name == 'schedule' && steps.tracking_comment.outputs.fallback_streak_days != '' }}
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          title="Alert: Capture coverage using fallback fixture source"
          source_variant="${{ steps.tracking_comment.outputs.source_variant }}"
          streak="${{ steps.tracking_comment.outputs.fallback_streak_days }}"
          threshold="${{ steps.fallback_alert.outputs.threshold_days }}"
          run_url="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${{ github.run_id }}"

          if [[ ! "$streak" =~ ^[0-9]+$ ]]; then
            echo "Skipping fallback alert management: invalid streak '$streak'."
            exit 0
          fi
          if [[ ! "$threshold" =~ ^[0-9]+$ ]] || [[ "$threshold" -lt 1 ]]; then
            threshold="3"
          fi

          existing_issue_number="$(gh issue list \
            --repo "${GITHUB_REPOSITORY}" \
            --state open \
            --search "\"${title}\" in:title" \
            --json number,title \
            --jq ".[] | select(.title == \"${title}\") | .number" | head -n 1)"

          if [[ "$source_variant" == "fallback_fixture" && "$streak" -ge "$threshold" ]]; then
            body_path="/tmp/fallback-fixture-alert-${{ github.run_id }}.md"
            {
              echo "<!-- coverage-fallback-fixture-alert:v1 -->"
              echo "# Alert: Capture coverage uses fallback fixture source"
              echo
              echo "- Latest run: ${run_url}"
              echo "- Source variant: \`${source_variant}\`"
              echo "- Consecutive fallback fixture days: \`${streak}\`"
              echo "- Alert threshold days: \`${threshold}\`"
              echo
              echo "## Action needed"
              echo "- Configure real source via \`CLINICAL_HUB_URL\` or \`CLINICAL_HUB_DB_URL\` repository secret."
            } > "$body_path"

            if [[ -n "$existing_issue_number" ]]; then
              gh issue edit "$existing_issue_number" \
                --repo "${GITHUB_REPOSITORY}" \
                --add-label warning \
                --body-file "$body_path" > /dev/null
              echo "Updated fallback-source alert issue #$existing_issue_number."
            else
              new_url="$(gh issue create \
                --repo "${GITHUB_REPOSITORY}" \
                --title "$title" \
                --label warning \
                --body-file "$body_path")"
              echo "Created fallback-source alert issue: $new_url"
            fi
          elif [[ -n "$existing_issue_number" ]]; then
            gh issue comment "$existing_issue_number" \
              --repo "${GITHUB_REPOSITORY}" \
              --body "Resolved in ${run_url}: source_variant=\`${source_variant}\`, streak=\`${streak}\`, threshold=\`${threshold}\`." > /dev/null
            gh issue close "$existing_issue_number" \
              --repo "${GITHUB_REPOSITORY}" > /dev/null
            echo "Closed fallback-source alert issue #$existing_issue_number."
          else
            echo "Fallback-source alert conditions not met. No issue update required."
          fi

      - name: Enforce hard coverage gates
        if: ${{ always() && steps.filters.outputs.enforce_coverage_gates == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ steps.gates.outputs.hard_passed }}" != "true" ]]; then
            echo "Hard coverage gates failed."
            exit 1
          fi
          echo "Hard coverage gates passed."
